
\chapter{Introduction}
  Vulnerabilities in software can have serious consequences, including reputation damage,
  financial losses, or even loss of life in the case of critical infrastructure systems. Most of them
  are introduced during the development process as a result of hidden errors, which might not appear
  suspicious at first. The system and its users or their data are at~risk until flaws are patched.
  That is the main reason and motivation why it is important to~constantly improve the security of products.

  Cloned vulnerabilities are security weaknesses that are introduced into a software system
  when code is copied or reused from another system that contains the vulnerability.
  These vulnerabilities can be difficult to detect and fix, because they are not necessarily introduced
  intentionally, instead, they are inherited from the source code that was copied or reused. In software
  engineering, the approach of cloning similar functional parts already implemented in~other applications
  is usually applied. It makes the development of new products or adding features to existing ones swifter.

  For this case, a good example is cryptocurrencies which became very popular in recent years.
  Namely, Bitcoin, an Open-Source peer-to-peer electronic cash system created by Satoshi Nakamoto
  \cite{bitcoin} inspired many new projects that joined the cryptocurrency market. Lots~of them were created
  as derivatives of Bitcoin with the idea to extend or improve its features. Cloning helped to speed up
  the development of new coins by inheriting its base infrastructure.

  Although, neither a large-scale project developed by the community as Bitcoin is always perfect. Plenty of
  vulnerabilities were discovered in its code base which were accordingly documented and are stored
  and tracked in vulnerability databases. As there are many other coins that share its code, it is possible
  that they also share the same vulnerabilities. The question inspired this work to develop a monitoring tool
  with the goal to analyze the~threat and help with the detection of vulnerable code and its occurrence in
  cloned projects, as the identification is not an easy but rather costly and exhaustive process
  and after identification yet also patching the issue is desired.

  The prevalence of code reuse and the increasing complexity of software systems makes cloned vulnerabilities
  an important issue to consider in software development and maintenance. This thesis aims to study the
  characteristics and impacts of cloned vulnerabilities and to identify effective approaches for detecting
  and mitigating them. The proposed tool in this work considers disclosed vulnerabilities which means
  that the issue was already patched in the project that was originally affected by it. Thanks to this fact
  the tool can identify an~issue, the affected code in the original project, and candidate projects with
  the~probability of vulnerability inheritance. Additionally, the tool can also propose a patch for
  the detected threat.

  An existing tool, with the same goal described above, was implemented in a project named CoinWatch
  \cite{CoinWatch} with an aim on vulnerabilities in cryptocurrencies. The CoinWatch inspired this work
  with an idea to bring improvements, extensions, and a graphical user interface for wider and simplified
  usage of the tool for detecting and mitigating cloned vulnerabilities.

  This thesis begins with a basic introduction to the problem and the motivation for why it is relevant
  to deal with. Chapter \ref{chapter:vulnerabilities} explains and takes a closer look at vulnerabilities
  and the basic terminology connected with them. In chapter \ref{chapter:detection-tools}, current detection
  tools and approaches are described and analyzed. Afterwards, chapter \ref{chapter:design} describes
  a draft of the tool built for detecting cloned vulnerabilities. The next two chapters
  \ref{chapter:implementation} and \ref{chapter:experimentation} contain implementation details
  and an evaluation of the developed product. The final chapter \ref{chapter:conclusion} concludes this work
  with potential improvements for future work.


\chapter{Vulnerabilities in Software Applications}
\label{chapter:vulnerabilities}
  Software vulnerabilities and exposures are weaknesses or flaws in software products that are
  exploitable in a cyber attack. The exploitation of a vulnerability can allow an attacker unauthorized
  access, elevation of privileges or denial of service.\,\cite{SoftwareVulnerabilities}
  Most of the known vulnerabilities are associated with dealing with input provided by a user
  of the application. For instance, some frequent types of vulnerabilities include buffer overflows,
  cross site scripting, and SQL injections.\,\cite{vulnerabilities} The mistakes causing these issues
  can be introduced during the development process or by using insecure libraries and frameworks.

  The consequences of vulnerabilities in software applications can be quite serious like data breaches,
  theft of sensitive information, or damage to a product infrastructure. For instance, consider
  vulnerability, in Microsoft Windows implementation of Server Message Block protocol, with an identifier
  CVE-2017-0144. An exploitation of this flaw, by sending crafted packets, allows remote attackers to run
  arbitrary code on a target machine. This defect facilitated the spreading of worm-like ransomware
  \emph{WannaCry} through the network in~2017, which affected many organizations, companies, and individuals.
  \cite{WannaCry}
  % https://nvd.nist.gov/vuln/detail/CVE-2017-0144
  % https://www.zdnet.com/article/ransomware-an-executive-guide-to-one-of-the-biggest-menaces-on-the-web/

  Ransomware is a type of malicious software, that locks up the victim's data or device and threatens to delete
  or keep it locked unless a ransom is paid to an attacker.\,\cite{Malware} In the case of \emph{WannaCry},
  the malware would encrypt files on the victim's device and ask for a ransom of value 300 USD in Bitcoin
  if paid within the first three days, otherwise, the value would be doubled for the next four days and if
  not paid at all, the files would be lost forever.
  % https://www.ibm.com/topics/ransomware
  % https://www.csoonline.com/article/3227906/wannacry-explained-a-perfect-ransomware-storm.html

  In order to mitigate repeated occurrences and time consuming process of patching, each
  vulnerability and exposure is documented and stored in a database, so repeated mistakes in implementation
  can be mitigated or fixed faster. This source provides valuable information for the public,
  security engineers, and for tools working with weaknesses in software applications to improve
  cyber security.

  \newpage

  \begin{figure}[h]
    \centering
    \includegraphics[width=0.9\textwidth]{obrazky-figures/wannacry_distribution_bc.pdf}
    \caption{WannaCry ransomware distribution}
  \end{figure}

  \section{Prevention and Mitigation}
  Preventing and mitigating software vulnerabilities is crucial for ensuring the security and reliability
  of developed software. This section presents some secure coding practices for the prevention
  and mitigation of weaknesses from being introduced during the development of a~product.

  \subsection*{Input Validation and Sanitization}
    An input of an application or service can have different sources which can be divided based on trustworthiness.
    For example, internal communication between services is considered to be a trusted source. On the other side,
    Input from a user is considered to be an untrusted source because the data received can be anything.
    This makes it important to validate it properly, so that malformed input will not harm the system or lead
    to unexpected behaviour. An~example of insufficient validation are SQL injections. To improve input
    validation these points should be considered:
    \begin{itemize}
      \item check all inputs from untrusted sources
      \item check usage of proper character sets (UTF-8, ASCII, ...)
      \item encode data to a common character set before validation
      \item validate all received data for type, length, format, and range
      \item validate received data against a "white" list of allowed characters, when possible
      \item process special and hazardous characters with increased precision to address double encoding or other
            forms of obfuscation attacks
      \item all validation failures should result in input rejection
    \end{itemize}

  \subsection*{Output Encoding and Sanitization}
    When it comes to a trusted source of messages between services, some checks might be omitted as internal
    communication can be performed through an internal interface. Omitting of some validations, in this case,
    can benefit in better performance of the system. To achieve this goal it is essential to comply with
    all items mentioned in the previous subsection, so the exchanged messages should be correctly encoded
    and sanitized. Sanitization should be mainly done on data for commands to the operating system and queries
    for SQL, XML, and LDAP.

  \subsection*{Authentication and Password Management}
    Authentication is a process of validating the identity of a user, device, or system. It is used for
    ensuring restricted access to private resources or certain actions. Some authentication methods
    are:
    \begin{itemize}
      \item passwords -- typically used in combination with a user name
      \item two\,-factor authentication (2FA) -- this method requires two different forms of authentication
            to validate identity
      \item biometric authentication -- this type requires physical or behavioural actions, like
            face recognition or fingerprint, for identification
    \end{itemize}
    By implementing strong authentication methods into the system, organizations can prevent identity theft
    and protect against unauthorized access. Here are some practices on implementation, configuration
    and password management improvement:
    \begin{itemize}
      \item require authentication for all resources, except for those intended to be public
      \item authorization should be fail secure
      \item credentials should be stored only as cryptographically strong one-way salted hashes of passwords
            and storage should be writeable only by the application
      \item validate authentication only on completion of all input fields, especially in case of sequential
            authentication
      \item use only HTTP POST request for sending authentication data
      \item enforce higher password complexity -- length, numeric and/or special characters
      \item enforce account disabling after a number of failed login attempts, the duration should
            be sufficient to discourage guessing credentials by brute-force attack, but not to allow
            denial-of-service attack
      \item notify the user on password change
      \item allow next password change at least after one day from the last change
    \end{itemize}

  \bigskip

  More advice on secure coding practices can be found in \cite{SecureCodingPractices}. Nevertheless, mistakes
  tend to slip into production versions of software. At this stage, other options are to use vulnerability
  scanning tools, write automated tests or perform penetration testing to discover hidden weaknesses, before
  they are exploited. Scanning tools are a form of static analysis. They work by searching the application's code/binary
  for vulnerable patterns. Details of such tools are analysed in the next chapter \ref{chapter:detection-tools}.
  Automated tests and penetration testing are forms of dynamic analysis. They discover run-time issues
  in the built and running application or its parts.

%  \section{Types of Software Errors}
%  Vulnerabilities are often caused by a coding mistake during development. This section presents a variety
%  of types of errors, which are mostly the result of forgotten validations mentioned in the previous section.
%  It is also important to note that the probability of these errors occurring is affected by the programming
%  language used and its capabilities, such as memory management. Below are described examples of issues frequently
%  contained within CVEs. \cite{UnforgivableVulnerabilities}
%  \subsection*{Buffer Overflow}
%  \subsection*{Cross Site Scripting}
%  \subsection*{SQL Injection}

  \section{Identifiers Related to Security Vulnerabilities}

  \subsection*{CPE -- Common Platform Enumeration}
    CPE refers to a standardized method for describing and identifying abstract classes of software
    and hardware products present in an organization's computing infrastructure. The standard was created
    by the National Institute of Standards and Technology (NIST) as~the part of the Common Vulnerabilities
    and Exposures (CVE) program. The current version of CPE is 2.3 and is used to identify products
    in vulnerability databases. It is represented as formatted string binding with colon-delimited
    list of components prefixed with the string "\texttt{cpe:2.3:}". \cite{CPEnaming}\\
      \centerline{\texttt{cpe:2.3: part : vendor : product : version : update : edition :}}\\
      \centerline{\texttt{language : sw\_edition : target\_sw : target\_hw : other}}

  \subsection*{CWE -- Common Weakness Enumeration}
    CWE is a community-developed formal list of common software and hardware weakness types that
    have security ramifications, which was released in 2006. The CWE database is maintained by the MITRE Corporation
    and as of 28th December 2022, it contains 933 records. The main goal of CWE is to stop vulnerabilities
    at the source by educating software and hardware architects, designers, programmers, and acquirers
    on how to eliminate the most common mistakes before products are delivered. \cite{CWE}

    The severity of weaknesses can be evaluated by Common Weakness Scoring System (CWSS). It provides a method
    for prioritizing software weaknesses. It is a collaborative, community-based effort that is addressing
    the needs of its stakeholders. \cite{CWSS}

    Current top 3 ranking contains \cite{CWEtop25}:
    \begin{itemize}
      \item \textbf{CWE-787} -- Out-of-bounds Write
      \item \textbf{CWE-79} -- Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')
      \item \textbf{CWE-89} -- Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')
    \end{itemize}

  \subsection*{CVSS -- Common Vulnerability Scoring System}
  CVSS captures technical characteristics of software, hardware and firmware vulnerabilities. It attempts
  to assign severity scores to vulnerabilities. The score is in the range of 0.0 -- 10.0, where higher numbers represent
  more severe vulnerabilities. The metric is composed of three metric groups -- base, temporal and environmental --
  and helps with the prioritization of vulnerabilities. \cite{CVSSFirst, CVSSresearchgate}

  \begin{figure}[h]
    \centering
    \includegraphics[width=0.9\textwidth]{obrazky-figures/cvss_metric_groups.png}
    \caption{Three CVSS metric groups. Source: \cite{CVSSFirst}}
  \end{figure}

%   https://www.first.org/cvss/v3-1/cvss-v31-specification_r1.pdf
%   https://www.researchgate.net/publication/311694508_The_Common_Vulnerability_Scoring_System_CVSS_generations_-_usefulness_and_deficiencies

  \section{Vulnerability Databases}
  % https://wiww.researchgate.net/publication/316971384_Analyzing_Vulnerability_Databases
  In 1989 the Computer Emergency Response Team (CERT) was established at the Software Engineering Institute
  at Carnegie Mellon University to find, collect and publish all information about known vulnerabilities.
  After CERT displayed all collected vulnerabilities publicly, they started to appear in many new databases
  with different formats of weakness information. The most popular vulnerability databases were analysed
  in \cite{VulnDBs}, but as of December 2022, some of them are shut down or not maintained.

  \subsection*{CVE -- Common Vulnerabilities and Exposures}
    CVE is a list of publicly disclosed computer security flaws. It was released in 1999, at a time when
    most cybersecurity tools used their own databases, names and evaluations of weaknesses. Now, CVE provides
    a database and a unified standard for naming information security vulnerabilities.

    The process of creating a new CVE identifier begins with discovering and reporting a potential security
    vulnerability. The information is accordingly assigned a unique CVE identifier by a CVE Naming Authority
    (CNA) and posted to the list on the CVE website by an editor. The MITRE Corporation functions as the editor
    and primary CNA. \cite{CVE}

    Each entry in the list contains the following fields: CVE identifier number, brief description and references.
    The CVE identifier number format looks like "\texttt{CVE-YYYY-NNNN}", where
    '\texttt{Y}' refers to a year of creation and '\texttt{N}' is unique number assigned to the vulnerability.
    As~of 29th December 2022, the database contains 191\,855 CVE records\footnote{\href{https://cve.mitre.org}
    {https://cve.mitre.org}} and is synchronized with the following database.

  \subsection*{NVD -- National Vulnerability Database}
  The NVD was established in 2005 to provide the U. S. government with a repository of data about software
  vulnerabilities. It is a product of the National Institute of Standards and Technology (NIST) to provide
  vulnerability management information. The NVD can be used to prioritize the vulnerabilities to address
  in order to secure important systems.

  The database is based on and synchronized with the CVE list and enhances the base CVE scheme for vulnerability
  severity metrics and updates them when new information about the vulnerability is provided. CVSS is used
  for evaluation and helps to understand the potential severity of each vulnerability. NIST works directly
  with vendors and researchers to assure the quality of published data and provide the public with accurate
  scoring data. \cite{NVD}

  Information about vulnerabilities is accessible to the public via the web page or REST API provided
  by the organization. As~of 29th December 2022, the database contains 203\,312 records providing the following
  data\footnote{\href{https://nvd.nist.gov/general/nvd-dashboard}{https://nvd.nist.gov/general/nvd-dashboard}}:
  \begin{itemize}
      \item Base CVE Entry Schema -- Identification, Description, References
      \item Source Identifier -- Reporter
      \item Publication Time
      \item Last Modification Time
      \item Status
      \item Metrics -- CVSS
      \item Weaknesses -- contained CWEs
      \item Configurations -- CPE
  \end{itemize}

%  \subsection*{VulnDB}
%  The VulnDB contains comprehensive vulnerability intelligence and provides actionable information about
%  the latest security vulnerabilities. The contents of the database are available via their web portal
%  or RESTful API. It allows organizations to search and be alerted on the latest vulnerabilities
%  in end-user software, libraries and dependencies. This database states to contain 307,250 vulnerabilities
%  and is a part of a threat intelligence platform provided by a company named Flashpoint which acquired Risk
%  Based Security (RBS). RBS is original founder of the VulnDB, previously named Open Sourced Vulnerability
%  Database (OSVDB).

\newpage


\chapter{Detection Tools and Approaches}
\label{chapter:detection-tools}
  The previous chapter mentioned some suggestions on what to do to prevent vulnerabilities from being
  introduced in the software during development. This chapter will analyse options on what can be done
  to scan or test the security of a system for hidden flaws in a production version.

  \section{Web Scraping and Vulnerability Data Parsing}

  \section{Code Evolution Analysis - SZZ Algorithm}

  \section{Identification of Vulnerable Code}

  \section{Clone Detection}
    \subsection*{Types of Clones}
      There are three types of clones we register nowadays. Depending on  how similar they are to their
      origins, they are divided into groups:
      \paragraph{Type I. Clones}
      \paragraph{Type II. Clones}
      \paragraph{Type III. Clones}

  \section{Existing Tools}

    \subsection*{CoinWatch}
      Introduction (Purpose, ...) \\
      Workflow, references

    \subsection*{Other tools}


\chapter{Design}
\label{chapter:design}


\chapter{Implementation}
\label{chapter:implementation}


\chapter{Experimentation}
\label{chapter:experimentation}


\chapter{Conclusion}
\label{chapter:conclusion}
